<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <title>mxgraph示例</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        .com-box{position:relative; width:1200px; height: 600px; margin:0 auto;}
        .com-box .sidebar{position:absolute; padding: 10px 10px 0 10px; width:100px; height:600px; background-color: #fff; box-shadow: 0 1px 1px rgba(0,0,0,.2); border-radius: 2px;}
        .sidebar .shape-item{display: block; margin:0 auto 10px; width:100px; height:100px; cursor:move; text-align: center;}
        .sidebar .shape-item img{width:90%; transition:transform ease-in-out .2s;}
        .sidebar .shape-item span{ color: #666; }
        .sidebar .shape-item img:hover{transform:scale(1.15);}
        .com-box .main{position:absolute; left:140px; margin: 0; width:1060px; overflow: auto; background:url('images/grid.gif');}
        .btn-wrap{padding-left:160px; width:1080px;}
        #js-autoLayout{height: 38px;margin-right: 13px;position: relative;top: -1px;}
        #input-xml{ text-align: center; margin-bottom: 30px; }
    </style>
</head>
<body>
    <h2 class="main title">综合示例</h2>
    <h3 class="main sub-title"><a href="index.html">&lt;返回</a></h3>
    <div class="com-box">
        <div class="sidebar">
            <a href="javascript:;" class="shape-item">
                <span>查询</span>
                <img src="images/binoculars.png" alt="查询" data-flag="inquire">
            </a>
            <a href="javascript:;" class="shape-item">
                <span>排重</span>
                <img src="images/direction_sign.png" alt="排重" data-flag="heavy_discharge">
            </a>
            <a href="javascript:;" class="shape-item">
                <span>抽样</span>
                <img src="images/lamp.png" alt="抽样" data-flag="sampling">
            </a>
            <a href="javascript:;" class="shape-item">
                <span>目标组</span>
                <img src="images/tedy_bear.png" alt="目标组" data-flag="target_group">
            </a>
            <a href="javascript:;" class="shape-item">
                <span>短信</span>
                <img src="images/message.png" alt="短信" data-flag="SMS">
            </a>
        </div>
        <div class="main" id="wrap"></div>
    </div>

    <div class="btn-wrap">
        <select id="js-autoLayout">
            <option value="mxFastOrganicLayout">mxFastOrganicLayout</option>
            <option value="mxCircleLayout">mxCircleLayout</option>
            <option value="mxCompactTreeLayout">mxCompactTreeLayout</option>
            <option value="mxPartitionLayout">mxPartitionLayout</option>
            <option value="mxEdgeLabelLayout">mxEdgeLabelLayout</option>
            <option value="mxParallelEdgeLayout">mxParallelEdgeLayout-带参</option>
            <option value="mxRadialTreeLayout">mxRadialTreeLayout</option>
            <option value="mxStackLayout">mxStackLayout-带参</option>
        </select>
        <button id="js-btnGetXml">导出xml</button>
        <button id="js-btnSetXml">加载xml</button>
        <button id="js-btnEnlarge">放大</button>
        <button id="js-btnShrinkDown">缩小</button>
        <button id="js-btnExportImage">导出图片</button>
        <button id="js-btnNotConnect">设置排重图标不能连接目标组</button>
    </div>
    <!--对应弹窗内容模板，对应每个栏目组cell 的 cellType，对于每个栏目组的内容写在这里面，通过ajax获取数据进行渲染-->
    <!--建议用表单提交-->
    <!--参照[https://aui.github.io/art-template][art-template]语法-->
    <!--时间节点-->
    <script id="time" type="text/html">
        <div class="inquire-container">
            <label for="nodeName">时间节点时间值</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}"> <!--cell 唯一标识-->
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>
    <!--查询-->
    <script id="inquire" type="text/html">
        <div class="inquire-container">
            <label for="nodeName">查询节点名称</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}"> <!--cell 唯一标识-->
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>
    <!--排重-->
    <script id="heavy_discharge" type="text/html">
        <div class="heavy_discharge-container">
            <label for="nodeName">排重节点名称</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}">
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>
    <!--抽样-->
    <script id="sampling" type="text/html">
        <div class="sampling-container">
            <label for="nodeName">抽样节点名称</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}">
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>

    <!--目标组-->
    <script id="target_group" type="text/html">
        <div class="target_group-container">
            <label for="nodeName">目标组节点名称</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}">
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>

    <!--短信-->
    <script id="SMS" type="text/html">
        <div class="SMS-container">
            <label for="nodeName">短信节点名称</label>
            <input type="text" name="nodeName" id="nodeName"  value="{{cell.value}}" />
            <input type="hidden" name="guid" id="guid" value="{{cell.guid}}">
            <ul>
                <li>我是通过ajax获取的数据</li>
                {{each list}}
                    <li>{{$value}}</li>
                {{/each}}
            </ul>
            <button class="cell-save-btn">保存</button>
        </div>
    </script>

    <div id="input-xml">
        <h6>输入xml，然后点击“加载xml按钮”</h6>
        <textarea id="js-txt" cols="60" rows="10"></textarea>
    </div>
    <script type="text/javascript">mxBasePath = '../src';</script>
    <script type="text/javascript" src="../src/js/mxClient.js"></script>
    <script type="text/javascript" src="../src/js/template-web.js"></script>
    <script>

    //MyGraph类
    /*
        参数：
        container: 绘图容器，必须
        cellImages: 拖拽的栏目图片
        cellImgContianer 栏目组容器
        modalWindowCallback 点击cell时弹框出现执行的回调函数
     */
    function MyGraph(options){
        var fileSupport = window.File != null && window.FileReader != null && window.FileList != null;
        if (!fileSupport && !mxClient.isBrowserSupported()){
            mxUtils.error('Browser is not supported!', 200, false);
        }
        //继承超类-构造函数
        this.container = options.container;
        this.cellImages = options.cellImages;
        this.cellImgContianer = options.cellImgContianer;
        this.modalWindowCallback = options.modalWindowCallback
        mxGraph.call(this, this.container);
        this.parent = this.getDefaultParent();
        this.defineConstantForGraph();
        this.initData();
        this.setGlobalStyle();
        this.initDraw();
        this.initEvent();
        this.initClipboard();
    }
    MyGraph.prototype = new mxGraph();
    MyGraph.prototype.constructor = MyGraph;
    MyGraph.prototype.defineConstantForGraph = function(){
        //ports（渲染对应栏目组的接口）
        this.ports = {

        }
        //弹框size[width,height]
        this.windowSize = {
            time: [400, 300],
            inquire: [800, 400],
            heavy_discharge: [600, 600],
            sampling: [200, 200],
            target_group: [300, 600],
            SMS: [700, 700]
        }
        //栏目组
        this.column = {
            time: '时间',
            inquire: '查询',
            heavy_discharge: '排重',
            sampling: '抽样',
            target_group: '目标组',
            SMS: '短信'
        }
        this.layoutWay = {
            mxFastOrganicLayout: mxFastOrganicLayout,
            mxCircleLayout: mxCircleLayout,
            mxCompactTreeLayout: mxCompactTreeLayout,
            mxCompositeLayout: mxCompositeLayout, //暂不支持
            mxEdgeLabelLayout: mxEdgeLabelLayout,
            mxParallelEdgeLayout: mxParallelEdgeLayout,
            mxPartitionLayout: mxPartitionLayout,
            mxRadialTreeLayout: mxRadialTreeLayout,
            mxStackLayout: mxStackLayout
        }
    }
    MyGraph.prototype.initData = function(){
        var _self = this;
        this.setConnectable(true);// 允许连接
        this.setPanning(true);
        this.orderCells(true);//使线在所有元素的底下,吸附元素
        this.setTooltips(true); //允许显示tooltip
        // this.setAutoSizeCells(true); //cell自适应拉伸
        this.setAllowDanglingEdges(false); //禁止悬空edges
        this.edgeLabelsMovable = false;
        //安装右键菜单,且阻止默认右键行为
        mxEvent.disableContextMenu(this.container);
        this.popupMenuHandler.factoryMethod = function(menu, cell, evt){
            return _self.createPopupMenu(_self, menu, cell, evt);
        };
        //自定义tooltip
        this.getTooltipForCell = function(cell){
            var cellValue = '';
            cellValue += _self.column[cell.cellType] ? '所属栏目组：' + _self.column[cell.cellType] + ' ' : '';
            cellValue += cell.value ? 'Label：' + cell.value : '';
            return cellValue;
        }
        this.rubberband = new mxRubberband(this); //橡皮筋，允许按住鼠标选择多个cell
        this.undoManager = new mxUndoManager(); //撤销和恢复对象
    }
    //定义无效连接
    MyGraph.prototype.defineInvalidConnect = function(instance){
        this.multiplicities.push(instance);
    }
    //初始化事件
    MyGraph.prototype.initEvent = function(){
        var _self = this;
        //监听cell变化,解决两个cell不能同时既当target，又当source的问题
        this.getModel().addListener(mxEvent.CHANGE, function(sender, event){
            _self.validateGraph();
            //识别source和target只能有一条线
            var changes = event.getProperty('edit').changes;
            var childs = changes.filter(function(item){
                return item.child;
            })
            if(childs.length > 0 && childs[0].parent){
                // console.log(childs)
                var child = childs[0].child;
                var parent = childs[0].parent.children;
                // console.log(childs[0].parent);
                var edges = parent.filter(function(item){
                    return item.edge;
                })
                // console.log(edges);
                // console.info(changes);
                if(_self.connectTarget && _self.connectSource){
                    for (var i = edges.length - 1; i >= 0; i--) {
                        if(edges[i].source.guid === _self.connectTarget.guid && edges[i].target.guid === _self.connectSource.guid){
                            _self.connectTarget = null;
                            _self.connectSource = null;
                            setTimeout(function(){ _self.removeSelectedCell(); }, 0);
                            break;
                        }
                    }
                }
            }
        });

        //连接时的监听
        this.connectionHandler.addListener(mxEvent.CONNECT, function(sender, evt){
                var edge = evt.getProperty('cell');
                var source = _self.getModel().getTerminal(edge, true);
                var target = _self.getModel().getTerminal(edge, false);
                // console.log(edge)
                // console.log(source)
                // console.log(target)
                _self.connectSource = source;
                _self.connectTarget = target;
        });

        //监听撤销和恢复操作
        var listener = function(sender, evt){
          _self.undoManager.undoableEditHappened(evt.getProperty('edit'));
        };
        this.getModel().addListener(mxEvent.UNDO, listener);
        this.getView().addListener(mxEvent.UNDO, listener);
        this.getModel().addListener(mxEvent.REDO, listener);
        this.getView().addListener(mxEvent.REDO, listener);


        // 上下左右键盘监听
        var nudge = function(keyCode){
            if (!_self.isSelectionEmpty()){
                var dx = 0;
                var dy = 0;
                if (keyCode == 37){
                    dx = -1;
                }
                else if (keyCode == 38){
                    dy = -1;
                }
                else if (keyCode == 39){
                    dx = 1;
                }
                else if (keyCode == 40){
                    dy = 1;
                }
                _self.moveCells(_self.getSelectionCells(), dx, dy);
            }
        };
        var keyHandler = new mxKeyHandler(this);
        // Ignores enter keystroke. Remove this line if you want the
        // enter keystroke to stop editing
        keyHandler.enter = function() {};
        keyHandler.bindKey(37, function(){
            nudge(37);
        });
        keyHandler.bindKey(38, function(){
            nudge(38);
        });
        keyHandler.bindKey(39, function(){
            nudge(39);
        });
        keyHandler.bindKey(40, function(){
            nudge(40);
        });

        //拖拽外部图片（转换成base64）
        mxEvent.addListener(this.container, 'dragover', function(evt){
            if (_self.isEnabled()){
                evt.stopPropagation();
                evt.preventDefault();
            }
        });
        mxEvent.addListener(this.container, 'drop', function(evt) {
            if (_self.isEnabled()){
                evt.stopPropagation();
                evt.preventDefault();
                // Gets drop location point for vertex
                var pt = mxUtils.convertPoint(_self.container, mxEvent.getClientX(evt), mxEvent.getClientY(evt));
                var tr = _self.view.translate;
                var scale = _self.view.scale;
                var x = pt.x / scale - tr.x;
                var y = pt.y / scale - tr.y;
                // Converts local images to data urls
                var filesArray = event.dataTransfer.files;
                for (var i = 0; i < filesArray.length; i++)
                {
                    _self.handleDrop(_self, filesArray[i], x + i * 10, y + i * 10);
                }
            }
        });
        //双击插入图标
        mxEvent.addListener(this.cellImgContianer, 'dblclick', function(evt){
            var dx = 0, cell = new mxCell(evt.target.alt, new mxGeometry(0, 0, 90, 90),'style1;perimeterSpacing=4;strokeWidth=4;labelBackgroundColor=white;fontStyle=1');
            //赋予目标组标志位(自定义)
            cell.cellType = evt.target.dataset.flag;
            //定义唯一Id
            cell.guid = cell.cellType + '-' + _self.myUtil().getGuid(8,16);
            cell.vertex = true;
            _self.setCellStyles(mxConstants.STYLE_IMAGE, "image;image="+evt.target.getAttribute('src'), [cell]); //单独设置cell的背景图
            _self.getTooltipForCell(cell);
            while(Boolean(_self.getCellAt(dx,0,_self.getDefaultParent()))){
                //图片高度、宽度,因为左右两个角都在cell里面，所以会执行两次，所以需要再减去90
                dx += 90;
            }
            var cells = _self.importCells([cell], dx===0 ? 0 : dx-90, 0, _self.getDefaultParent());
            if (cells != null && cells.length > 0)
            {
             _self.scrollCellToVisible(cells[0]);
             _self.setSelectionCells(cells);
            }
        });
        //双击点击cell,弹出设置窗口
        this.dblClick = function(evt, cell){
            if (this.isEnabled() && !mxEvent.isConsumed(evt) && cell != null && this.isCellEditable(cell)){
                if (this.model.isEdge(cell)){
                    return;
                }
                else{
                    this.myUtil().showModalWindow(this.getModalWindowConfig(cell));
                }
            }
            // Disables any default behaviour for the double click
            mxEvent.consume(evt);
        }
    }
    //得到cell弹窗配置
    MyGraph.prototype.getModalWindowConfig = function(cell){
        //defineConstantForGraph
        console.log(cell)
        var _self = this;
        if(cell.id === 'begin'){ return; }
        function getTitle(){
            return _self.column[cell.cellType || cell.id] + '节点';
        }
        function getContent(){
            //可以通过异步获取数据，根据cell唯一标识和cellType类型，获取数据
            var data = {
                cell: cell,
                list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']
            },
            content = document.createElement('div'),
            html = template(cell.cellType || cell.id, data); //cell.cellType与模板id保持一致，有可能是时间节点，所以可能情况是cell.id
            content.innerHTML = html;
            return content;
        }
        function getSize(){
            //可以根据cell.cellType返回不同的宽度
            return _self.windowSize[cell.cellType || cell.id];
        }
        return {
            graph: this,
            cell: cell,
            title: getTitle(),
            content: getContent(),
            width: getSize()[0],
            height: getSize()[1]
        }
    }
    //拖拽图片转换成base64以xml形式插入contianer
    MyGraph.prototype.handleDrop = function(graph, file, x, y){
        if (file.type.substring(0, 5) == 'image'){
            var reader = new FileReader();
            reader.onload = function(e){
                // Gets size of image for vertex
                var data = e.target.result;

                // SVG needs special handling to add viewbox if missing and
                // find initial size from SVG attributes (only for IE11)
                if (file.type.substring(0, 9) == 'image/svg'){
                    var comma = data.indexOf(',');
                    var svgText = atob(data.substring(comma + 1));
                    var root = mxUtils.parseXml(svgText);
                    // Parses SVG to find width and height
                    if (root != null){
                        var svgs = root.getElementsByTagName('svg');
                        if (svgs.length > 0){
                            var svgRoot = svgs[0];
                            var w = parseFloat(svgRoot.getAttribute('width'));
                            var h = parseFloat(svgRoot.getAttribute('height'));
                            // Check if viewBox attribute already exists
                            var vb = svgRoot.getAttribute('viewBox');
                            if (vb == null || vb.length == 0)
                            {
                                svgRoot.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
                            }
                            // Uses width and height from viewbox for
                            // missing width and height attributes
                            else if (isNaN(w) || isNaN(h))
                            {
                                var tokens = vb.split(' ');
                                if (tokens.length > 3)
                                {
                                    w = parseFloat(tokens[2]);
                                    h = parseFloat(tokens[3]);
                                }
                            }
                            w = Math.max(1, Math.round(w));
                            h = Math.max(1, Math.round(h));
                            data = 'data:image/svg+xml,' + btoa(mxUtils.getXml(svgs[0], '\n'));
                            graph.insertVertex(null, null, '', x, y, w, h, 'shape=image;image=' + data + ';verticalLabelPosition=bottom;verticalAlign=top');
                        }
                    }
                }
                else{
                    var img = new Image();
                    img.onload = function(){
                        var w = Math.max(1, img.width);
                        var h = Math.max(1, img.height);
                        // Converts format of data url to cell style value for use in vertex
                        var semi = data.indexOf(';');
                        if (semi > 0)
                        {
                            data = data.substring(0, semi) + data.substring(data.indexOf(',', semi + 1));
                        }

                        graph.insertVertex(null, null, '', x, y, w, h, 'shape=image;image=' + data + ';verticalLabelPosition=bottom;verticalAlign=top');
                    };
                    img.src = data;
                }
            };
            reader.readAsDataURL(file);
        }
    }
    //处理ctrl+c || ctrl+v复制粘贴 cell
    MyGraph.prototype.initClipboard = function(){
        var _self = this;
        // Public helper method for shared clipboard.
        mxClipboard.cellsToString = function(cells){
            var codec = new mxCodec();
            var model = new mxGraphModel();
            var parent = model.getChildAt(model.getRoot(), 0);
            for (var i = 0; i < cells.length; i++){
                model.add(parent, cells[i]);
            }
            return mxUtils.getXml(codec.encode(model));
        };

        // Focused but invisible textarea during control or meta key events
        var textInput = document.createElement('textarea');
        mxUtils.setOpacity(textInput, 0);
        textInput.style.width = '1px';
        textInput.style.height = '1px';
        var restoreFocus = false;
        var gs = _self.gridSize;
        var lastPaste = null;
        var dx = 0;
        var dy = 0;

        // Workaround for no copy event in IE/FF if empty
        textInput.value = ' ';
        // Shows a textare when control/cmd is pressed to handle native clipboard actions
        mxEvent.addListener(document, 'keydown', function(evt){
            // No dialog visible
            var source = mxEvent.getSource(evt);
            if (_self.isEnabled() && !_self.isMouseDown && !_self.isEditing() && source.nodeName != 'INPUT'){
                if (evt.keyCode == 224 /* FF */ || (!mxClient.IS_MAC && evt.keyCode == 17 /* Control */) || (mxClient.IS_MAC && evt.keyCode == 91 /* Meta */)){
                    // Cannot use parentNode for check in IE
                    if (!restoreFocus){
                        // Avoid autoscroll but allow handling of events
                        textInput.style.position = 'absolute';
                        textInput.style.left = (_self.container.scrollLeft + 10) + 'px';
                        textInput.style.top = (_self.container.scrollTop + 10) + 'px';
                        _self.container.appendChild(textInput);
                        restoreFocus = true;
                        textInput.focus();
                        textInput.select();
                    }
                }
            }
        });

        // Restores focus on graph container and removes text input from DOM
        mxEvent.addListener(document, 'keyup', function(evt){
            if (restoreFocus && (evt.keyCode == 224 /* FF */ || evt.keyCode == 17 /* Control */ ||
                evt.keyCode == 91 /* Meta */)){
                restoreFocus = false;
                if (!_self.isEditing()){
                    _self.container.focus();
                }
                textInput.parentNode.removeChild(textInput);
            }
        });

        // Inserts the XML for the given cells into the text input for copy
        var copyCells = function(graph, cells){
            if (cells.length > 0){
                var clones = _self.cloneCells(cells);
                // Checks for orphaned relative children and makes absolute
                for (var i = 0; i < clones.length; i++){
                    var state = _self.view.getState(cells[i]);
                    if (state != null){
                        var geo = _self.getCellGeometry(clones[i]);
                        if (geo != null && geo.relative){
                            geo.relative = false;
                            geo.x = state.x / state.view.scale - state.view.translate.x;
                            geo.y = state.y / state.view.scale - state.view.translate.y;
                        }
                    }
                }
                textInput.value = mxClipboard.cellsToString(clones);
            }
            textInput.select();
            lastPaste = textInput.value;
        };

        // Handles copy event by putting XML for current selection into text input
        mxEvent.addListener(textInput, 'copy', mxUtils.bind(this, function(evt){
            if (_self.isEnabled() && !_self.isSelectionEmpty()){
                copyCells(_self, mxUtils.sortCells(_self.model.getTopmostCells(_self.getSelectionCells())));
                dx = 0;
                dy = 0;
            }
        }));

        // Handles cut event by removing cells putting XML into text input
        mxEvent.addListener(textInput, 'cut', mxUtils.bind(this, function(evt){
            if (_self.isEnabled() && !_self.isSelectionEmpty()){
                copyCells(_self, _self.removeCells());
                dx = -gs;
                dy = -gs;
            }
        }));

        // Merges XML into existing graph and layers
        var importXml = function(xml, dx, dy){
            dx = (dx != null) ? dx : 0;
            dy = (dy != null) ? dy : 0;
            var cells = []

            try{
                var doc = mxUtils.parseXml(xml);
                var node = doc.documentElement;
                if (node != null)
                {
                    var model = new mxGraphModel();
                    var codec = new mxCodec(node.ownerDocument);
                    codec.decode(node, model);
                    var childCount = model.getChildCount(model.getRoot());
                    var targetChildCount = _self.model.getChildCount(_self.model.getRoot());
                    // Merges existing layers and adds new layers
                    _self.model.beginUpdate();
                    try{
                        for (var i = 0; i < childCount; i++) {
                            var parent = model.getChildAt(model.getRoot(), i);
                            // Adds cells to existing layers if not locked
                            if (targetChildCount > i){
                                // Inserts into active layer if only one layer is being pasted
                                var target = (childCount == 1) ? _self.getDefaultParent() : _self.model.getChildAt(_self.model.getRoot(), i);
                                if (!_self.isCellLocked(target)){
                                    var children = model.getChildren(parent);
                                    cells = cells.concat(_self.importCells(children, dx, dy, target));
                                }
                            }
                            else{
                                // Delta is non cascading, needs separate move for layers
                                parent = _self.importCells([parent], 0, 0, _self.model.getRoot())[0];
                                var children = _self.model.getChildren(parent);
                                _self.moveCells(children, dx, dy);
                                cells = cells.concat(children);
                            }
                        }
                    }
                    finally{
                        _self.model.endUpdate();
                    }
                }
            }
            catch (e){
                alert(e);
                throw e;
            }
            return cells;
        };

        // Parses and inserts XML into graph
        var pasteText = function(text){
            var xml = mxUtils.trim(text);
            var x = _self.container.scrollLeft / _self.view.scale - _self.view.translate.x;
            var y = _self.container.scrollTop / _self.view.scale - _self.view.translate.y;
            if (xml.length > 0){
                if (lastPaste != xml){
                    lastPaste = xml;
                    dx = 0;
                    dy = 0;
                }
                else{
                    dx += gs;
                    dy += gs;
                }
                // Standard paste via control-v
                if (xml.substring(0, 14) == '<mxGraphModel>')
                {
                    _self.setSelectionCells(importXml(xml, dx, dy));
                    _self.scrollCellToVisible(_self.getSelectionCell());
                }
            }
        };

        // Cross-browser function to fetch text from paste events
        var extractGraphModelFromEvent = function(evt){
            var data = null;
            if (evt != null){
                var provider = (evt.dataTransfer != null) ? evt.dataTransfer : evt.clipboardData;
                if (provider != null){
                    if (document.documentMode == 10 || document.documentMode == 11){
                        data = provider.getData('Text');
                    }
                    else {
                        data = (mxUtils.indexOf(provider.types, 'text/html') >= 0) ? provider.getData('text/html') : null;
                        if (mxUtils.indexOf(provider.types, 'text/plain' && (data == null || data.length == 0))){
                            data = provider.getData('text/plain');
                        }
                    }
                }
            }
            return data;
        };

        // Handles paste event by parsing and inserting XML
        mxEvent.addListener(textInput, 'paste', function(evt){
            // Clears existing contents before paste - should not be needed
            // because all text is selected, but doesn't hurt since the
            // actual pasting of the new text is delayed in all cases.
            textInput.value = '';
            if (_self.isEnabled()){
                var xml = extractGraphModelFromEvent(evt);
                if (xml != null && xml.length > 0) {
                    pasteText(xml);
                }
                else{
                    // Timeout for new value to appear
                    window.setTimeout(mxUtils.bind(this, function() {
                        pasteText(textInput.value);
                    }), 0);
                }
            }
            textInput.select();
        });

    }
    //自定义布局-工厂模式
    MyGraph.prototype.autoLayout = function(){
        var _self = this,
            args = Array.prototype.slice.call(arguments),
            way = args.shift();
        args.unshift(this);
        this.getModel().beginUpdate();
        try{
            if(way in this.layoutWay){

                var fConstructor = this, fNewConstr = function() {
                    fConstructor.layoutWay[way].apply(this, args);
                };
                fNewConstr.prototype = fConstructor.layoutWay[way].prototype;
                return new fNewConstr().execute(this.parent);

            }else{
                new mxFastOrganicLayout(this).execute(this.parent); //默认自动优化布局
            }
        }finally{
            //布局时需要有animation
            var morph = new mxMorphing(this);
            morph.addListener(mxEvent.DONE, function() {
                _self.getModel().endUpdate();
            });
            morph.startAnimation();
        }
    }
    //获取Graph xml 用于保存至保存数据库
    MyGraph.prototype.exportGraphToXml = function(){
        var encoder = new mxCodec();
        var node = encoder.encode(this.getModel());
        return mxUtils.getXml(node);
    }
    //通过xml还原Graph
    MyGraph.prototype.importGraphWithXml = function(xml){
        var doc = mxUtils.parseXml(xml),
            elt = doc.documentElement.firstChild.firstChild,
            codec = new mxCodec(doc),
            cells = [];

        while (elt != null){
          cells.push(codec.decodeCell(elt));
          this.refresh();
          elt = elt.nextSibling;
        }
        this.addCells(cells);
    }
    //删除选中cell
    MyGraph.prototype.removeSelectedCell = function(){
        var cells = this.getSelectionCells();
        if(cells[0].id === 'time' || cells[0].id === 'begin'){
            return;
        }
        this.removeCells(cells);
    }
    //导出图片
    MyGraph.prototype.exportGraphToImage = function(){
        var xmlDoc = mxUtils.createXmlDocument();
        var root = xmlDoc.createElement('output');
        xmlDoc.appendChild(root);
        var xmlCanvas = new mxXmlCanvas2D(root);
        var imgExport = new mxImageExport();
        imgExport.drawState(this.getView().getState(this.model.root), xmlCanvas);

        var bounds = this.getGraphBounds();
        var w = Math.ceil(bounds.x + bounds.width);
        var h = Math.ceil(bounds.y + bounds.height);
        var xml = mxUtils.getXml(root);
        console.log(xml)
        new mxXmlRequest('export', 'format=png&w=' + w +
             '&h=' + h + '&bg=#F9F7ED&xml=' + encodeURIComponent(xml))
             .simulate(document, '_blank');
    }
     MyGraph.prototype.myUtil = function(){
        var _self = this;
        return {
            //获取本地时间
            getLocalTime: function(){
                return new Date(parseInt(new Date().getTime())).toLocaleString().replace(/:\d{1,2}$/,' ');
            },
            //GUID
            getGuid: function(len, radix){
                var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
                var uuid = [], i;
                radix = radix || chars.length;
                if (len) {
                  // Compact form
                  for (i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
                } else {
                  // rfc4122, version 4 form
                  var r;
                  // rfc4122 requires these characters
                  uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
                  uuid[14] = '4';
                  // Fill in random data.  At i==19 set the high bits of clock sequence as
                  // per rfc4122, sec. 4.1.5
                  for (i = 0; i < 36; i++) {
                    if (!uuid[i]) {
                      r = 0 | Math.random()*16;
                      uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
                    }
                  }
                }
                return uuid.join('') + '-' + new Date().getTime();
            },
            //弹框
            showModalWindow: function(options){
                if(Object.prototype.toString.call(options) === "[object Undefined]" ||
                   Object.prototype.toString.call(options) === "[object Null]"){
                    return;
                }
                var background = document.createElement('div'),
                    graph = options.graph,
                    cell = options.cell,
                    title = options.title,
                    content = options.content,
                    width = options.width,
                    height = options.height;
                background.style.position = 'fixed';
                background.style.left = '0px';
                background.style.top = '0px';
                background.style.right = '0px';
                background.style.bottom = '0px';
                background.style.background = 'black';
                mxUtils.setOpacity(background, 50);
                document.body.appendChild(background);
                if (mxClient.IS_IE)
                {
                    new mxDivResizer(background);
                }
                var x = Math.max(0, document.body.scrollWidth/2-width/2);
                var y = Math.max(10, (document.body.scrollHeight ||
                            document.documentElement.scrollHeight)/2-height*2/3);
                var wnd = new mxWindow(title, content, x, y, width, height, false, true);
                wnd.setClosable(true);
                // Fades the background out after after the window has been closed
                wnd.addListener(mxEvent.DESTROY, function(evt)
                {
                    graph.setEnabled(true);
                    mxEffects.fadeOut(background, 50, true, 
                        10, 30, true);
                });
                graph.setEnabled(false);
                graph.tooltipHandler.hide();
                wnd.setScrollable(true);
                wnd.setVisible(true);
                _self.modalWindowCallback && _self.modalWindowCallback(_self,wnd,cell);
            }
        }
     }
    //设置全局样式
    MyGraph.prototype.setGlobalStyle = function(){

        //设置连接前hover样式
        mxConnectionHandler.prototype.connectImage = new mxImage('images/connector.gif', 16, 16);

        //设置edge默认样式
        var lineStyle = this.getStylesheet().getDefaultEdgeStyle();
        lineStyle[mxConstants.STYLE_EDGE] = mxEdgeStyle.ElbowConnector;
        lineStyle[mxConstants.STYLE_ROUNDED] = true;
        lineStyle[mxConstants.STYLE_ARCSIZE] = 10;
        lineStyle[mxConstants.STYLE_STROKEWIDTH] = 2;
        lineStyle[mxConstants.STYLE_LABEL_PADDING] = 3;
        lineStyle[mxConstants.STYLE_LABEL_BACKGROUNDCOLOR] = '#fff';

        //cell样式
        var style={};
        //Shape
        style[mxConstants.STYLE_SHAPE] = mxConstants.SHAPE_IMAGE;
        //Image
        style[mxConstants.STYLE_IMAGE_WIDTH]=90;
        style[mxConstants.STYLE_IMAGE_HEIGHT]=90;
        style[mxConstants.STYLE_IMAGE_ALIGN]=mxConstants.ALIGN_CENTER;
        style[mxConstants.STYLE_FILLCOLOR]='#446299';
        style[mxConstants.STYLE_STROKECOLOR]='#446299';
        //Label
        style[mxConstants.STYLE_VERTICAL_ALIGN]= mxConstants.ALIGN_TOP;
        style[mxConstants.STYLE_VERTICAL_LABEL_POSITION]= mxConstants.ALIGN_BOTTOM;
        style[mxConstants.STYLE_LABEL_WIDTH]= 90;
        this.getStylesheet().putCellStyle('style1',style);
    }
    //开始绘制
    MyGraph.prototype.initDraw = function(){
        var _self = this;
        // 尝试开始更新绘制
        _self.getModel().beginUpdate();
        try{
            //默认会显示开始->时间
            var containerHeight = _self.container.offsetHeight,
                offsetTop = (containerHeight - 90)/2,
                v1 = _self.insertVertex(_self.parent, 'begin', '开始', 20, offsetTop, 90, 90, 'style1;image;image=images/begin.png');
                v2 = _self.insertVertex(_self.parent, 'time', _self.myUtil().getLocalTime(), 200, offsetTop, 90, 90, 'style1;image;image=images/time.png');
                //定义唯一Id
                v2.guid = v2.id + '-' + _self.myUtil().getGuid(8,16);
                e1 = _self.insertEdge(_self.parent, null, '', v1, v2);

            var sideImgs = _self.cellImages;
            for(var i=0;i < sideImgs.length;i++){
                var funct;
                (function(i){
                    funct=function(graph, evt, target, x, y){
                        var cell = new mxCell(sideImgs[i].alt || '', new mxGeometry(0, 0, 90, 90),'style1;perimeterSpacing=4;strokeWidth=4;labelBackgroundColor=white;fontStyle=1');
                        //赋予目标组标志位(自定义)
                        cell.cellType = sideImgs[i].dataset.flag;
                        //定义唯一Id
                        cell.guid = cell.cellType + '-' + _self.myUtil().getGuid(8,16);
                        cell.vertex = true;
                        graph.setCellStyles(mxConstants.STYLE_IMAGE, "image;image="+sideImgs[i].getAttribute('src'), [cell]); //单独设置cell的背景图
                        graph.getTooltipForCell(cell);
                        var cells = graph.importCells([cell], x, y, target);
                        if (cells != null && cells.length > 0)
                        {
                         graph.scrollCellToVisible(cells[0]);
                         graph.setSelectionCells(cells);
                        }
                    }
                })(i)

                var dragElt = sideImgs[i].cloneNode(true);
                dragElt.style.width = '90px';
                var ds = mxUtils.makeDraggable(sideImgs[i], _self, funct, dragElt);
            }

        }finally{
            // 无论怎样都结束绘制
            _self.getModel().endUpdate();
        }
    }
    //创建右键菜单
    MyGraph.prototype.createPopupMenu = function(graph, menu, cell, evt){
        var _self = this;
        var publicAction = function(){
            menu.addSeparator();
            menu.addItem('放大', 'images/zoomin.gif', function()
            {
                _self.zoomIn();
            });
            menu.addItem('缩小', 'images/zoomout.gif', function()
            {
                _self.zoomOut();
            });
            menu.addItem('还原', 'images/zoomactual.gif', function()
            {
                _self.zoomActual();
            });
            menu.addSeparator();
            menu.addItem('打印', 'images/print.gif',function(evt)
            {
                var preview = new mxPrintPreview(_self, 1);
                preview.open();
            });
            menu.addSeparator();
            menu.addItem('撤销', 'images/undo.gif',function(evt)
            {
                if(_self.undoManager.canUndo()){
                    _self.undoManager.undo();
                }
            });
            menu.addItem('恢复', 'images/redo.gif',function(evt)
            {
                if(_self.undoManager.canRedo()){
                    _self.undoManager.redo();
                }
            });
        }
        if (cell != null){
            menu.addItem('删除', 'images/delete2.png', function()
            {
                _self.removeSelectedCell();
            });
            publicAction();
        }
        else{
            menu.addItem('No-Cell Item', 'images/warning.png', function()
            {
               return;
            });
            publicAction();
        }
        menu.addSeparator();
    }


        var wrap=document.getElementById('wrap');
        var cellImgContianer = document.querySelector('.sidebar');
        var cellImgs = document.querySelectorAll('.sidebar img');
        var myGraph = new MyGraph({
            container: wrap,
            cellImages: cellImgs,
            cellImgContianer: cellImgContianer,
            modalWindowCallback: function(graph,win,cell){
                var btn = document.querySelector('.cell-save-btn');
                var parent = btn.parentNode;
                btn.onclick = function(){
                    //保存数据时，必须更新cell label值
                    var value = parent.querySelector('#nodeName').value;
                    graph.getModel().beginUpdate();
                    try{
                        cell.setValue(value);
                        var edit = new mxCellAttributeChange(
                               cell, 'value',
                               value);
                        graph.getModel().execute(edit);
                    }
                    finally{
                        graph.getModel().endUpdate();
                        win.destroy();
                    }
                }
            }
        });

        //通过xml还原Graph
        document.querySelector('#js-btnSetXml').onclick=function(){
            var xml = document.querySelector('#js-txt').value;
            myGraph.importGraphWithXml(xml);
        }

        //获取xml
        document.querySelector('#js-btnGetXml').onclick=function(){
            mxUtils.popup(myGraph.exportGraphToXml(), true);
        }

        //自动优化布局
        document.querySelector('#js-autoLayout').onchange = function(){
            if(this.value === 'mxParallelEdgeLayout'){
                myGraph.autoLayout(this.value, true, 1, 2);
            }else if(this.value === 'mxStackLayout'){
                myGraph.autoLayout(this.value, true);
            }else{
                myGraph.autoLayout(this.value);
            }
        };

        //删除选中的cell
        document.onkeyup = function(e){
            if(e.keyCode == 46){
                myGraph.removeSelectedCell();
            }
        }

        //放大 js-btnEnlarge
        document.querySelector('#js-btnEnlarge').onclick = function(){
            myGraph.zoomIn();
        };

        //缩小 js-js-btnShrinkDown
        document.querySelector('#js-btnShrinkDown').onclick = function(){
            myGraph.zoomOut();
        };


        //导出图片
        document.querySelector('#js-btnExportImage').onclick = function(){
            myGraph.exportGraphToImage();
        };

        //设置两个图标不能连接
        function once(dom, event, callback) {
            var handle = function() {
                callback();
                dom.removeEventListener(event, handle, false);
            }
            dom.addEventListener(event, handle, false);
        }

        once(document.querySelector('#js-btnNotConnect'), 'click', function(){
            myGraph.defineInvalidConnect(new mxMultiplicity(
           false, '目标组', null, null, 0, 0, ['排重'],
           '排重不能连接到目标组'));
        });

    </script>
</body>
</html>